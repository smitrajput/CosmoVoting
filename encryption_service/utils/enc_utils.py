from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
import os
import json
import uuid
from config import config
import base64
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Protocol.KDF import PBKDF2
from Crypto.Hash import SHA256, SHA3_256


class EncUtils (object):

    @classmethod
    def get_aes_key(cls):
        """ Returns a random key of 128 bits """

        return get_random_bytes(16)

    @classmethod
    def get_random_bytes(cls, num_bytes):
        """ Returns randomly generated bytes of specified length """

        return get_random_bytes(num_bytes)

    @classmethod
    def get_rsa_key(cls):
        """ Returns randomly generated RSA key of length 2048 bits. """

        return RSA.generate(2048).export_key('PEM')

    @classmethod
    def get_sha256_hash(cls, message):
        """ Returns sha256 hash """

        h = SHA256.new()
        h.update(bytes(message, 'utf8'))
        return (h.hexdigest())

    @classmethod
    def get_sha3_256_hash(cls, message):
        """ Returns sha3 hash """

        h = SHA3_256.new()
        h.update(bytes(message, 'utf8'))
        return (h.hexdigest())

    # @classmethod
    # def get_user_session_key(cls, k1):
    #     """ Returns folder path to store encrypted oracle keys """

    #     user_session_data = MemCacheUtils.get("sesison_data", str(k1))
    #     return user_session_data["session_key"]

    @classmethod
    def derive_key_from_password(cls, password):
        """ Returns symmetric key of length 128 bits derived from a passphrase. Returns same key
        if same passphrase is supplied again """

        return (PBKDF2(bytes(password, 'utf8'), bytes(password, 'utf8'), 16))

    @classmethod
    def import_key(cls, key_bytes):
        """ Returns RSA key object from bytes"""
        return RSA.importKey(key_bytes)

    @classmethod
    def export_key(cls, key):
        """ Returns bytes from RSA key object """
        return key.export_key('PEM')

    @classmethod
    def encode(cls, data):
        """ do a base 64 encoding """
        encoded = base64.b64encode(data)
        return encoded

    @classmethod
    def decode(cls, encoded):
        """ do a base 64 decoding """
        decoded = base64.b64decode(encoded)
        return decoded

    @classmethod
    def encode_multiple(cls, data):
        """ do a base 64 encoding of multiple items """
        encoded_multiple = [cls.encode(item) for item in data]
        return encoded_multiple

    @classmethod
    def decode_multiple(cls, encoded):
        """ do a base 64 decoding of multiple items """
        decoded_multiple = [cls.decode(item) for item in encoded]
        return decoded_multiple

        
    @classmethod
    def encrypt(cls, message, public_key):
        """ Encrypt a message in bytes of length <= 190  using public key
         and returns ciphertext in bytes """
        cipher = PKCS1_OAEP.new(public_key)
        ciphertext = cipher.encrypt(message)
        return ciphertext

    @classmethod
    def decrypt(cls, ciphertext, private_key):
        """ Decrypt a ciphertext in bytes of length = 256 with private key
         and returns message in bytes """

        cipher = PKCS1_OAEP.new(private_key)
        original_message = cipher.decrypt(ciphertext)
        return original_message

    @classmethod
    def long_encrypt(cls, message_bytes, public_key):
        """ Encrpyt a string of bytes with length > 190 """
        # divide the message in parts and ecrypt
        n = config.get("max_message_length")
        num_chunks = int(len(message_bytes)/n) + 1
        ciphertext = []

        chunks = [message_bytes[i:i+n]
                  for i in range(0, len(message_bytes), n)]

        for i in range(0, num_chunks):
            ciphertext.append(cls.encrypt(chunks[i], public_key))

        # join the cipher bytes to make a single string of bytes
        encrypted_message_bytes = b"".join(ciphertext)
        return encrypted_message_bytes

    @classmethod
    def long_decrypt(cls, ciphertext_bytes, private_key):
        """ Decrpyt a string of ciphertext with length > 256 """
        # divide the ciphertext in piecies for decryption
        n2 = config.get("cipher_text_length")
        ciphertext_list = [ciphertext_bytes[i:i+n2]
                           for i in range(0, len(ciphertext_bytes), n2)]
        recovered_message = []

        # decrypt to get the original message
        for i in range(0, len(ciphertext_list)):
            recovered_message.append(cls.decrypt(
                ciphertext_list[i], private_key))

        # join the message
        original_message = b"".join(recovered_message)
        return original_message

    # encryption decryption functions
    @classmethod
    def symmetric_encrypt(cls, message_bytes, key):
        """ Encrypt a message using symmetric key and returns ciphertext in bytes """
        data = message_bytes
        cipher = AES.new(key, AES.MODE_EAX)
        ciphertext, tag = cipher.encrypt_and_digest(data)
        nonce = cipher.nonce
        encoded = cls.encode_multiple([nonce, tag, ciphertext])
        final_cipher = encoded[0] + encoded[1] + encoded[2]
        return final_cipher

    @classmethod
    def symmetric_decrypt(cls, final_cipher, key):
        """ Decrypt a ciphertext in bytes of length = 256 and returns message in bytes """

        encoded_nonce = final_cipher[0:24]
        encoded_tag = final_cipher[24:48]
        encoded_ciphertext = final_cipher[48:]
        [nonce, tag, ciphertext] = EncUtils.decode_multiple(
            [encoded_nonce, encoded_tag, encoded_ciphertext])
        cipher = AES.new(key, AES.MODE_EAX, nonce)
        data = cipher.decrypt_and_verify(ciphertext, tag)
        message = data
        return message